//! Output strategy pattern for flexible display modes
//!
//! This module implements the Strategy Pattern to decouple output display logic,
//! allowing runtime switching between different output modes:
//!
//! - `StreamingOutput` - Real-time streaming display (like Claude Code)
//! - `BatchOutput` - Collect all content, display at end
//! - `JsonOutput` - JSON format for SDK/API integration
//! - `SilentOutput` - No output (for testing or background tasks)

use crate::ui::Icons;
use colored::Colorize;
use std::io::{self, Write};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, Mutex};
use std::thread::{self, JoinHandle};
use std::time::Duration;

/// Output strategy trait for different display modes
///
/// Implementations of this trait control how LLM responses and tool executions
/// are displayed to the user.
pub trait OutputStrategy: Send + Sync {
    /// Called when content streaming starts (first chunk arrives)
    fn on_content_start(&self);

    /// Called for each content chunk during streaming
    fn on_content_chunk(&self, chunk: &str);

    /// Called when content streaming ends
    fn on_content_end(&self);

    /// Called when a tool execution starts
    fn on_tool_start(&self, name: &str, params: &str);

    /// Called when a tool execution completes
    fn on_tool_result(&self, success: bool, output: Option<&str>, error: Option<&str>);

    /// Called for thinking/status updates
    fn on_thinking(&self, message: &str);

    /// Called to stop thinking indicator
    fn on_thinking_stop(&self);

    /// Get the final collected content (for batch mode)
    fn get_collected_content(&self) -> Option<String> {
        None
    }
}

/// Streaming output - displays content in real-time as it arrives
///
/// This provides the best user experience for interactive use,
/// showing each token as it's generated by the LLM.
pub struct StreamingOutput {
    has_started: AtomicBool,
    /// Handle to the thinking animation thread
    thinking_handle: Mutex<Option<ThinkingAnimation>>,
}

/// Thinking animation that runs in a background thread
struct ThinkingAnimation {
    running: Arc<AtomicBool>,
    handle: Option<JoinHandle<()>>,
}

impl ThinkingAnimation {
    fn start(message: &str) -> Self {
        let running = Arc::new(AtomicBool::new(true));
        let running_clone = running.clone();
        let message = message.to_string();

        let handle = thread::spawn(move || {
            let frames = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"];
            let mut i = 0;

            while running_clone.load(Ordering::Relaxed) {
                print!(
                    "\r\x1b[K\x1b[2m{} {}\x1b[0m",
                    frames[i], message
                );
                let _ = io::stdout().flush();
                i = (i + 1) % frames.len();
                thread::sleep(Duration::from_millis(80));
            }

            // Clear the line when done
            print!("\r\x1b[K");
            let _ = io::stdout().flush();
        });

        Self {
            running,
            handle: Some(handle),
        }
    }

    fn stop(&mut self) {
        self.running.store(false, Ordering::Relaxed);
        if let Some(handle) = self.handle.take() {
            let _ = handle.join();
        }
    }
}

impl Drop for ThinkingAnimation {
    fn drop(&mut self) {
        self.running.store(false, Ordering::Relaxed);
    }
}

impl StreamingOutput {
    pub fn new() -> Self {
        Self {
            has_started: AtomicBool::new(false),
            thinking_handle: Mutex::new(None),
        }
    }
}

impl Default for StreamingOutput {
    fn default() -> Self {
        Self::new()
    }
}

impl OutputStrategy for StreamingOutput {
    fn on_content_start(&self) {
        // First clear any thinking indicator that might be on this line
        print!("\r\x1b[K");
        // Then print message indicator at column 0 (no leading spaces)
        print!("{} ", Icons::message().bright_white());
        let _ = io::stdout().flush();
        self.has_started.store(true, Ordering::SeqCst);
    }

    fn on_content_chunk(&self, chunk: &str) {
        // Add indent after each newline to align with text after icon
        // Format: "● text" -> newline needs "  " (2 spaces to align with text after icon)
        let indented = chunk.replace('\n', "\n  ");
        print!("{}", indented);
        let _ = io::stdout().flush();
    }

    fn on_content_end(&self) {
        if self.has_started.load(Ordering::SeqCst) {
            println!();
        }
        self.has_started.store(false, Ordering::SeqCst);
    }

    fn on_tool_start(&self, name: &str, params: &str) {
        // First clear any thinking indicator
        print!("\r\x1b[K");
        println!();
        // Icon at column 0 (no leading spaces)
        print!("{} {}", Icons::message().bright_blue(), name.bright_white().bold());
        if !params.is_empty() {
            println!("({})", params.dimmed());
        } else {
            println!();
        }
    }

    fn on_tool_result(&self, success: bool, output: Option<&str>, error: Option<&str>) {
        if success {
            if let Some(out) = output {
                // 2-space indent for tool result with └ tree symbol
                let preview: String = out.lines().take(3).collect::<Vec<_>>().join("\n    ");
                if !preview.trim().is_empty() {
                    let truncated = crate::utils::truncate_with_ellipsis(&preview, 200);
                    println!("  {} {}", Icons::result().dimmed(), truncated.dimmed());
                }
            }
        } else {
            let err_msg = error.unwrap_or("Unknown error");
            let first_line = err_msg.lines().next().unwrap_or(err_msg);
            let truncated = crate::utils::truncate_with_ellipsis(first_line, 80);
            println!("  {} {}", Icons::result().red(), truncated.red());
        }
    }

    fn on_thinking(&self, message: &str) {
        // Start animated thinking indicator
        if let Ok(mut handle) = self.thinking_handle.lock() {
            // Stop any existing animation first
            if let Some(ref mut anim) = *handle {
                anim.stop();
            }
            *handle = Some(ThinkingAnimation::start(message));
        }
    }

    fn on_thinking_stop(&self) {
        // Stop the animated thinking indicator
        if let Ok(mut handle) = self.thinking_handle.lock() {
            if let Some(ref mut anim) = *handle {
                anim.stop();
            }
            *handle = None;
        }
    }
}

/// Batch output - collects all content and displays at the end
///
/// Useful for:
/// - Environments where streaming isn't supported
/// - When you want to apply formatting (like markdown rendering) to complete content
/// - Logging or recording purposes
#[derive(Debug, Default)]
pub struct BatchOutput {
    content_buffer: Mutex<String>,
    tool_outputs: Mutex<Vec<String>>,
}

impl BatchOutput {
    pub fn new() -> Self {
        Self {
            content_buffer: Mutex::new(String::new()),
            tool_outputs: Mutex::new(Vec::new()),
        }
    }
}

impl OutputStrategy for BatchOutput {
    fn on_content_start(&self) {
        // Clear buffer for new content
        if let Ok(mut buffer) = self.content_buffer.lock() {
            buffer.clear();
        }
    }

    fn on_content_chunk(&self, chunk: &str) {
        // Accumulate in buffer
        if let Ok(mut buffer) = self.content_buffer.lock() {
            buffer.push_str(chunk);
        }
    }

    fn on_content_end(&self) {
        // Display all accumulated content at once (icon at column 0)
        if let Ok(buffer) = self.content_buffer.lock() {
            if !buffer.is_empty() {
                println!();
                println!("{} {}", Icons::message().bright_white(), buffer);
            }
        }
    }

    fn on_tool_start(&self, name: &str, params: &str) {
        println!();
        // Icon at column 0 (no leading spaces)
        print!("{} {}", Icons::message().bright_blue(), name.bright_white().bold());
        if !params.is_empty() {
            println!("({})", params.dimmed());
        } else {
            println!();
        }
    }

    fn on_tool_result(&self, success: bool, output: Option<&str>, error: Option<&str>) {
        if success {
            if let Some(out) = output {
                if let Ok(mut outputs) = self.tool_outputs.lock() {
                    outputs.push(out.to_string());
                }
                // 2-space indent for tool result with └ tree symbol
                let preview: String = out.lines().take(3).collect::<Vec<_>>().join("\n    ");
                if !preview.trim().is_empty() {
                    let truncated = crate::utils::truncate_with_ellipsis(&preview, 200);
                    println!("  {} {}", Icons::result().dimmed(), truncated.dimmed());
                }
            }
        } else {
            let err_msg = error.unwrap_or("Unknown error");
            let first_line = err_msg.lines().next().unwrap_or(err_msg);
            let truncated = crate::utils::truncate_with_ellipsis(first_line, 80);
            println!("  {} {}", Icons::result().red(), truncated.red());
        }
    }

    fn on_thinking(&self, message: &str) {
        // Icon at column 0 (no leading spaces)
        println!("{} {}", Icons::cogitate().dimmed(), message.dimmed());
    }

    fn on_thinking_stop(&self) {
        // Nothing to do for batch mode
    }

    fn get_collected_content(&self) -> Option<String> {
        self.content_buffer.lock().ok().map(|b| b.clone())
    }
}

/// JSON output - outputs structured JSON for SDK/API integration
///
/// Each event is output as a JSON object on a separate line (JSON Lines format).
/// Useful for:
/// - SDK/API consumers
/// - Piping to other tools
/// - Machine-readable output
#[derive(Debug, Default)]
pub struct JsonOutput {
    content_buffer: Mutex<String>,
}

impl JsonOutput {
    pub fn new() -> Self {
        Self {
            content_buffer: Mutex::new(String::new()),
        }
    }

    fn emit_event(&self, event_type: &str, data: serde_json::Value) {
        let event = serde_json::json!({
            "type": event_type,
            "data": data,
            "timestamp": chrono::Utc::now().to_rfc3339()
        });
        println!("{}", serde_json::to_string(&event).unwrap_or_default());
    }
}

impl OutputStrategy for JsonOutput {
    fn on_content_start(&self) {
        if let Ok(mut buffer) = self.content_buffer.lock() {
            buffer.clear();
        }
        self.emit_event("content_start", serde_json::json!({}));
    }

    fn on_content_chunk(&self, chunk: &str) {
        if let Ok(mut buffer) = self.content_buffer.lock() {
            buffer.push_str(chunk);
        }
        self.emit_event("content_chunk", serde_json::json!({ "chunk": chunk }));
    }

    fn on_content_end(&self) {
        let content = self.content_buffer.lock().ok().map(|b| b.clone());
        self.emit_event("content_end", serde_json::json!({ "content": content }));
    }

    fn on_tool_start(&self, name: &str, params: &str) {
        self.emit_event("tool_start", serde_json::json!({
            "name": name,
            "params": params
        }));
    }

    fn on_tool_result(&self, success: bool, output: Option<&str>, error: Option<&str>) {
        self.emit_event("tool_result", serde_json::json!({
            "success": success,
            "output": output,
            "error": error
        }));
    }

    fn on_thinking(&self, message: &str) {
        self.emit_event("thinking", serde_json::json!({ "message": message }));
    }

    fn on_thinking_stop(&self) {
        self.emit_event("thinking_stop", serde_json::json!({}));
    }
}

/// Silent output - produces no output
///
/// Useful for:
/// - Testing
/// - Background tasks
/// - When output is handled elsewhere
#[derive(Debug, Default, Clone, Copy)]
pub struct SilentOutput;

impl SilentOutput {
    pub fn new() -> Self {
        Self
    }
}

impl OutputStrategy for SilentOutput {
    fn on_content_start(&self) {}
    fn on_content_chunk(&self, _chunk: &str) {}
    fn on_content_end(&self) {}
    fn on_tool_start(&self, _name: &str, _params: &str) {}
    fn on_tool_result(&self, _success: bool, _output: Option<&str>, _error: Option<&str>) {}
    fn on_thinking(&self, _message: &str) {}
    fn on_thinking_stop(&self) {}
}

/// Rnk UI output - sends events to the new declarative UI
///
/// Uses the event bridge to update AppState, which rnk then renders.
/// This replaces terminal print! calls with state updates.
#[derive(Debug, Default)]
pub struct RnkOutput {
    content_buffer: Mutex<String>,
}

impl RnkOutput {
    pub fn new() -> Self {
        Self {
            content_buffer: Mutex::new(String::new()),
        }
    }
}

impl OutputStrategy for RnkOutput {
    fn on_content_start(&self) {
        if let Ok(mut buffer) = self.content_buffer.lock() {
            buffer.clear();
        }
        crate::ui::bridge::emit_event(crate::ui::bridge::AgentEvent::ContentStreamStarted);
    }

    fn on_content_chunk(&self, chunk: &str) {
        if let Ok(mut buffer) = self.content_buffer.lock() {
            buffer.push_str(chunk);
        }
        crate::ui::bridge::emit_event(crate::ui::bridge::AgentEvent::ContentChunk {
            chunk: chunk.to_string(),
        });
    }

    fn on_content_end(&self) {
        crate::ui::bridge::emit_event(crate::ui::bridge::AgentEvent::ContentStreamEnded);
    }

    fn on_tool_start(&self, name: &str, params: &str) {
        crate::ui::bridge::emit_event(crate::ui::bridge::AgentEvent::ToolExecutionStarted {
            tool_name: name.to_string(),
            tool_id: String::new(),
            description: params.to_string(),
        });
    }

    fn on_tool_result(&self, success: bool, output: Option<&str>, error: Option<&str>) {
        let result_preview = if success { output } else { error };
        crate::ui::bridge::emit_event(crate::ui::bridge::AgentEvent::ToolExecutionCompleted {
            tool_name: String::new(),
            tool_id: String::new(),
            success,
            duration_ms: 0,
            result_preview: result_preview.map(|s| s.to_string()),
        });
    }

    fn on_thinking(&self, _message: &str) {
        crate::ui::bridge::emit_event(crate::ui::bridge::AgentEvent::ThinkingStarted);
    }

    fn on_thinking_stop(&self) {
        crate::ui::bridge::emit_event(crate::ui::bridge::AgentEvent::ThinkingStopped);
    }

    fn get_collected_content(&self) -> Option<String> {
        self.content_buffer.lock().ok().map(|b| b.clone())
    }
}

/// Output mode configuration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OutputMode {
    /// Real-time streaming output (default)
    #[default]
    Streaming,
    /// Batch output (collect then display)
    Batch,
    /// JSON output for SDK/API
    Json,
    /// Silent (no output)
    Silent,
    /// Rnk declarative UI output
    Rnk,
}

impl OutputMode {
    /// Create the appropriate output strategy for this mode
    pub fn create_strategy(&self) -> Box<dyn OutputStrategy> {
        match self {
            OutputMode::Streaming => Box::new(StreamingOutput::new()),
            OutputMode::Batch => Box::new(BatchOutput::new()),
            OutputMode::Json => Box::new(JsonOutput::new()),
            OutputMode::Silent => Box::new(SilentOutput::new()),
            OutputMode::Rnk => Box::new(RnkOutput::new()),
        }
    }
}

impl std::str::FromStr for OutputMode {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "streaming" | "stream" => Ok(OutputMode::Streaming),
            "batch" => Ok(OutputMode::Batch),
            "json" => Ok(OutputMode::Json),
            "silent" | "quiet" => Ok(OutputMode::Silent),
            "rnk" | "ui" => Ok(OutputMode::Rnk),
            _ => Err(format!("Unknown output mode: {}", s)),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_streaming_output() {
        let output = StreamingOutput::new();
        output.on_content_start();
        output.on_content_chunk("Hello ");
        output.on_content_chunk("World!");
        output.on_content_end();
    }

    #[test]
    fn test_batch_output() {
        let output = BatchOutput::new();
        output.on_content_start();
        output.on_content_chunk("Hello ");
        output.on_content_chunk("World!");

        let content = output.get_collected_content();
        assert_eq!(content, Some("Hello World!".to_string()));

        output.on_content_end();
    }

    #[test]
    fn test_silent_output() {
        let output = SilentOutput::new();
        output.on_content_start();
        output.on_content_chunk("This should not appear");
        output.on_content_end();
    }

    #[test]
    fn test_output_mode_from_str() {
        assert_eq!("streaming".parse::<OutputMode>().unwrap(), OutputMode::Streaming);
        assert_eq!("batch".parse::<OutputMode>().unwrap(), OutputMode::Batch);
        assert_eq!("json".parse::<OutputMode>().unwrap(), OutputMode::Json);
        assert_eq!("silent".parse::<OutputMode>().unwrap(), OutputMode::Silent);
    }
}
