[
  {
    "instance_id": "sympy__sympy-17022",
    "model_patch": "diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex d41802eb95..6451171730 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -776,6 +776,18 @@ def _print_CodegenArrayPermuteDims(self, expr):\n     def _print_CodegenArrayElementwiseAdd(self, expr):\n         return self._expand_fold_binary_op('numpy.add', expr.args)\n \n+    def _print_Identity(self, expr):\n+        from sympy.core.symbol import Symbol\n+        n = expr.shape[0]\n+        \n+        # Check if the dimension is symbolic\n+        if isinstance(n, Symbol) or not n.is_integer:\n+            raise NotImplementedError(\n+                \"Symbolic dimensions for Identity matrices cannot be converted to NumPy code\"\n+            )\n+        \n+        return \"%s(%s)\" % (self._module_format('numpy.eye'), self._print(n))\n+\n \n for k in NumPyPrinter._kf:\n     setattr(NumPyPrinter, '_print_%s' % k, _print_known_func)\n",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13933",
    "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 422bc5d178..60b08519dc 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1188,7 +1188,7 @@ class ModelChoiceField(ChoiceField):\n     # This class is a subclass of ChoiceField for purity, but it doesn't\n     # actually use any of ChoiceField's implementation.\n     default_error_messages = {\n-        'invalid_choice': _('Select a valid choice. That choice is not one of'\n+        'invalid_choice': _('Select a valid choice. %(value)s is not one of'\n                             ' the available choices.'),\n     }\n     iterator = ModelChoiceIterator\n@@ -1284,7 +1284,11 @@ class ModelChoiceField(ChoiceField):\n                 value = getattr(value, key)\n             value = self.queryset.get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n-            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n+            raise ValidationError(\n+                self.error_messages['invalid_choice'], \n+                code='invalid_choice', \n+                params={'value': value}\n+            )\n         return value\n \n     def validate(self, value):\ndiff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex 8f41ce9c40..e4aa86ead0 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -51,17 +51,18 @@ class ModelChoiceFieldTests(TestCase):\n         # instantiated. This proves clean() checks the database during clean()\n         # rather than caching it at instantiation time.\n         Category.objects.get(url='4th').delete()\n-        msg = \"['Select a valid choice. That choice is not one of the available choices.']\"\n-        with self.assertRaisesMessage(ValidationError, msg):\n+        with self.assertRaises(ValidationError) as cm:\n             f.clean(c4.id)\n+        self.assertEqual(cm.exception.messages, [f'Select a valid choice. {c4.id} is not one of the available choices.'])\n \n     def test_clean_model_instance(self):\n         f = forms.ModelChoiceField(Category.objects.all())\n         self.assertEqual(f.clean(self.c1), self.c1)\n         # An instance of incorrect model.\n-        msg = \"['Select a valid choice. That choice is not one of the available choices.']\"\n-        with self.assertRaisesMessage(ValidationError, msg):\n-            f.clean(Book.objects.create())\n+        book = Book.objects.create()\n+        with self.assertRaises(ValidationError) as cm:\n+            f.clean(book)\n+        self.assertEqual(cm.exception.messages, [f'Select a valid choice. {book} is not one of the available choices.'])\n \n     def test_clean_to_field_name(self):\n         f = forms.ModelChoiceField(Category.objects.all(), to_field_name='slug')\n@@ -216,7 +217,7 @@ class ModelChoiceFieldTests(TestCase):\n         form = ModelChoiceForm({}, instance=book)\n         self.assertEqual(\n             form.errors['author'],\n-            ['Select a valid choice. That choice is not one of the available choices.']\n+            ['Select a valid choice. None is not one of the available choices.']\n         )\n \n     def test_disabled_modelchoicefield_has_changed(self):\n@@ -373,3 +374,27 @@ class ModelChoiceFieldTests(TestCase):\n         )\n         with self.assertNumQueries(2):\n             template.render(Context({'form': CategoriesForm()}))\n+\n+    def test_invalid_choice_error_includes_value(self):\n+        \"\"\"\n+        Test that the invalid_choice error message includes the invalid value.\n+        \"\"\"\n+        f = forms.ModelChoiceField(Category.objects.all())\n+        \n+        # Test with a non-existent integer ID\n+        invalid_id = 99999\n+        with self.assertRaises(ValidationError) as cm:\n+            f.clean(invalid_id)\n+        self.assertEqual(cm.exception.messages, [f'Select a valid choice. {invalid_id} is not one of the available choices.'])\n+        \n+        # Test with a string value\n+        invalid_string = 'invalid_value'\n+        with self.assertRaises(ValidationError) as cm:\n+            f.clean(invalid_string)\n+        self.assertEqual(cm.exception.messages, [f'Select a valid choice. {invalid_string} is not one of the available choices.'])\n+        \n+        # Test with to_field_name\n+        f_slug = forms.ModelChoiceField(Category.objects.all(), to_field_name='slug')\n+        with self.assertRaises(ValidationError) as cm:\n+            f_slug.clean('nonexistent_slug')\n+        self.assertEqual(cm.exception.messages, ['Select a valid choice. nonexistent_slug is not one of the available choices.'])\n",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-14382",
    "model_patch": "diff --git a/django/core/management/templates.py b/django/core/management/templates.py\nindex 8dc60682..f248ab1b 100644\n--- a/django/core/management/templates.py\n+++ b/django/core/management/templates.py\n@@ -74,7 +74,7 @@ class TemplateCommand(BaseCommand):\n                 raise CommandError(e)\n         else:\n             if app_or_project == 'app':\n-                self.validate_name(os.path.basename(target), 'directory')\n+                self.validate_name(os.path.basename(target.rstrip(os.sep)), 'directory')\n             top_dir = os.path.abspath(os.path.expanduser(target))\n             if not os.path.exists(top_dir):\n                 raise CommandError(\"Destination directory '%s' does not \"\n",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11099",
    "model_patch": "diff --git a/django/contrib/auth/validators.py b/django/contrib/auth/validators.py\nindex b4878cfd45..9345c5cb0b 100644\n--- a/django/contrib/auth/validators.py\n+++ b/django/contrib/auth/validators.py\n@@ -7,7 +7,7 @@ from django.utils.translation import gettext_lazy as _\n \n @deconstructible\n class ASCIIUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'^[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only English letters, '\n         'numbers, and @/./+/-/_ characters.'\n@@ -17,7 +17,7 @@ class ASCIIUsernameValidator(validators.RegexValidator):\n \n @deconstructible\n class UnicodeUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'^[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only letters, '\n         'numbers, and @/./+/-/_ characters.'\n",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11179",
    "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..e981798ce6 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -277,6 +277,7 @@ class Collector:\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, instance._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n",
    "model_name_or_path": "sage-agent"
  }
]