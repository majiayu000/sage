[
  {
    "instance_id": "django__django-10914",
    "model_patch": "diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py\nindex acee9887..146d0cbd 100644\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -304,7 +304,9 @@ FILE_UPLOAD_TEMP_DIR = None\n \n # The numeric mode to set newly-uploaded files to. The value should be a mode\n # you'd pass directly to os.chmod; see https://docs.python.org/library/os.html#files-and-directories.\n-FILE_UPLOAD_PERMISSIONS = None\n+# Default to 0o644 to ensure consistent permissions across different upload methods\n+# (MemoryUploadedFile vs TemporaryUploadedFile) and avoid umask-dependent behavior.\n+FILE_UPLOAD_PERMISSIONS = 0o644\n \n # The numeric mode to assign to newly-created directories, when uploading files.\n # The value should be a mode as you'd pass to os.chmod;\ndiff --git a/docs/ref/settings.txt b/docs/ref/settings.txt\nindex 46e99af9..9589dbaa 100644\n--- a/docs/ref/settings.txt\n+++ b/docs/ref/settings.txt\n@@ -1484,16 +1484,22 @@ This value mirrors the functionality and caveats of the\n ``FILE_UPLOAD_PERMISSIONS``\n ---------------------------\n \n-Default: ``None``\n+Default: ``0o644``\n \n The numeric mode (i.e. ``0o644``) to set newly uploaded files to. For\n more information about what these modes mean, see the documentation for\n :func:`os.chmod`.\n \n-If this isn't given or is ``None``, you'll get operating-system\n-dependent behavior. On most platforms, temporary files will have a mode\n-of ``0o600``, and files saved from memory will be saved using the\n-system's standard umask.\n+If this is set to ``None``, you'll get operating-system dependent behavior. \n+On most platforms, temporary files will have a mode of ``0o600``, and files \n+saved from memory will be saved using the system's standard umask. This can \n+result in inconsistent permissions depending on whether the upload was handled\n+by :class:`~django.core.files.uploadhandler.MemoryFileUploadHandler` or\n+:class:`~django.core.files.uploadhandler.TemporaryFileUploadHandler`.\n+\n+The default of ``0o644`` ensures consistent permissions across different upload\n+methods while maintaining appropriate security (owner read/write, group and \n+others read-only).\n \n For security reasons, these permissions aren't applied to the temporary files\n that are stored in :setting:`FILE_UPLOAD_TEMP_DIR`.\ndiff --git a/docs/topics/http/file-uploads.txt b/docs/topics/http/file-uploads.txt\nindex 21a6f068..db63480c 100644\n--- a/docs/topics/http/file-uploads.txt\n+++ b/docs/topics/http/file-uploads.txt\n@@ -214,6 +214,38 @@ Changing upload handler behavior\n There are a few settings which control Django's file upload behavior. See\n :ref:`File Upload Settings <file-upload-settings>` for details.\n \n+.. _file-upload-permissions:\n+\n+File Upload Permissions\n+-----------------------\n+\n+When files are uploaded using Django's :class:`~django.db.models.FileField` or\n+FileSystemStorage, the permissions of the resulting files are controlled by the\n+:setting:`FILE_UPLOAD_PERMISSIONS` setting. \n+\n+By default, Django sets uploaded file permissions to ``0o644`` (owner read/write,\n+group and others read-only). This ensures:\n+\n+* Consistent permissions regardless of whether the file was handled by\n+  :class:`~django.core.files.uploadhandler.MemoryFileUploadHandler` or\n+  :class:`~django.core.files.uploadhandler.TemporaryFileUploadHandler`\n+* Predictable behavior across different systems and umask configurations\n+* Sufficient permissions for web servers to read uploaded files while maintaining\n+  security\n+\n+Prior to Django 5.0, the default was ``None``, which meant file permissions\n+depended on the system's umask and could vary between the two upload handlers.\n+If you need the old behavior, you can set ``FILE_UPLOAD_PERMISSIONS = None`` in\n+your settings.\n+\n+For directory permissions created during file uploads, see the\n+:setting:`FILE_UPLOAD_DIRECTORY_PERMISSIONS` setting.\n+\n+.. warning::\n+\n+    Be careful when making uploaded files executable or writable by group/others,\n+    as this can create security vulnerabilities on shared systems.\n+\n .. _modifying_upload_handlers_on_the_fly:\n \n Modifying upload handlers on the fly\ndiff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex 43486955..85bf55f4 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -899,6 +899,50 @@ class FileStoragePermissions(unittest.TestCase):\n         mode = os.stat(self.storage.path(fname))[0] & 0o777\n         self.assertEqual(mode, 0o666 & ~self.umask)\n \n+    def test_file_upload_new_default_permissions(self):\n+        \"\"\"\n+        Test that the new default FILE_UPLOAD_PERMISSIONS (0o644) is applied\n+        when no explicit setting is provided.\n+        \"\"\"\n+        self.storage = FileSystemStorage(self.storage_dir)\n+        fname = self.storage.save(\"some_file\", ContentFile(\"data\"))\n+        mode = os.stat(self.storage.path(fname))[0] & 0o777\n+        self.assertEqual(mode, 0o644)\n+\n+    def test_file_upload_permissions_consistency(self):\n+        \"\"\"\n+        Test that file permissions are consistent regardless of upload method.\n+        This addresses the issue where TemporaryUploadedFile and InMemoryUploadedFile\n+        could result in different permissions when FILE_UPLOAD_PERMISSIONS was None.\n+        \"\"\"\n+        from django.core.files.uploadhandler import MemoryFileUploadHandler, TemporaryFileUploadHandler\n+        from django.core.files.uploadedfile import InMemoryUploadedFile, TemporaryUploadedFile\n+        \n+        # Simulate small file upload (InMemoryUploadedFile)\n+        memory_handler = MemoryFileUploadHandler()\n+        memory_handler.new_file('test_file', 'test.txt', 'text/plain', 10, 'utf-8', {})\n+        memory_handler.receive_data_chunk(b'test data', 0)\n+        memory_file = memory_handler.file_complete(10)\n+        \n+        # Save InMemoryUploadedFile\n+        self.storage.save(\"memory_file\", memory_file)\n+        memory_mode = os.stat(self.storage.path(\"memory_file\"))[0] & 0o777\n+        \n+        # Simulate large file upload (TemporaryUploadedFile) \n+        temp_handler = TemporaryFileUploadHandler()\n+        temp_handler.new_file('test_file', 'test.txt', 'text/plain', 10, 'utf-8', {})\n+        temp_handler.receive_data_chunk(b'test data', 0)\n+        temp_file = temp_handler.file_complete(10)\n+        \n+        # Save TemporaryUploadedFile\n+        self.storage.save(\"temp_file\", temp_file)\n+        temp_mode = os.stat(self.storage.path(\"temp_file\"))[0] & 0o777\n+        \n+        # Both should have the same permissions (0o644)\n+        self.assertEqual(memory_mode, 0o644)\n+        self.assertEqual(temp_mode, 0o644)\n+        self.assertEqual(memory_mode, temp_mode)\n+\n     @override_settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o765)\n     def test_file_upload_directory_permissions(self):\n         self.storage = FileSystemStorage(self.storage_dir)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-10924",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748c..2f099493 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1668,6 +1668,15 @@ class FilePathField(Field):\n         kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n+    def _get_path(self):\n+        \"\"\"\n+        Return the evaluated path. If path is a callable, call it and return the result.\n+        Otherwise, return the path as-is.\n+        \"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1688,7 +1697,12 @@ class FilePathField(Field):\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n         if self.path != '':\n-            kwargs['path'] = self.path\n+            if callable(self.path):\n+                # For callable paths, we need to preserve the callable in migrations\n+                # We'll store a representation that can be reconstructed\n+                kwargs['path'] = self.path\n+            else:\n+                kwargs['path'] = self.path\n         if self.match is not None:\n             kwargs['match'] = self.match\n         if self.recursive is not False:\n@@ -1709,7 +1723,7 @@ class FilePathField(Field):\n \n     def formfield(self, **kwargs):\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': self._get_path(),\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11001",
    "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7649c392..9812b54a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -353,7 +353,9 @@ class SQLCompiler:\n             # not taken into account so we strip it. When this entire method\n             # is refactored into expressions, then we can check each part as we\n             # generate it.\n-            without_ordering = self.ordering_parts.search(sql).group(1)\n+            # Normalize whitespace to handle multiline RawSQL expressions correctly\n+            sql_normalized = ' '.join(sql.split())\n+            without_ordering = self.ordering_parts.search(sql_normalized).group(1)\n             params_hash = make_hashable(params)\n             if (without_ordering, params_hash) in seen:\n                 continue\n@@ -366,7 +368,9 @@ class SQLCompiler:\n         if self.query.distinct and not self.query.distinct_fields:\n             select_sql = [t[1] for t in select]\n             for expr, (sql, params, is_ref) in order_by:\n-                without_ordering = self.ordering_parts.search(sql).group(1)\n+                # Normalize whitespace to handle multiline RawSQL expressions correctly\n+                sql_normalized = ' '.join(sql.split())\n+                without_ordering = self.ordering_parts.search(sql_normalized).group(1)\n                 if not is_ref and (without_ordering, params) not in select_sql:\n                     extra_select.append((expr, (without_ordering, params), None))\n         return extra_select",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11019",
    "model_patch": "diff --git a/django/forms/forms.py b/django/forms/forms.py\nindex dd562099..b7890eda 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -454,10 +454,21 @@ class BaseForm:\n     @property\n     def media(self):\n         \"\"\"Return all media required to render the widgets on this form.\"\"\"\n-        media = Media()\n+        # Collect all media lists from widgets to avoid artificial ordering constraints\n+        # that can occur during incremental merges.\n+        css_lists = []\n+        js_lists = []\n+        \n         for field in self.fields.values():\n-            media = media + field.widget.media\n-        return media\n+            widget_media = field.widget.media\n+            css_lists.extend(widget_media._css_lists)\n+            js_lists.extend(widget_media._js_lists)\n+        \n+        # Create a single media object with all lists and let it resolve the ordering\n+        combined = Media()\n+        combined._css_lists = css_lists\n+        combined._js_lists = js_lists\n+        return combined\n \n     def is_multipart(self):\n         \"\"\"",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11039",
    "model_patch": "",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11049",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex f32ce646..87b944fd 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1587,10 +1587,14 @@ class DurationField(Field):\n     empty_strings_allowed = False\n     default_error_messages = {\n         'invalid': _(\"'%(value)s' value has an invalid format. It must be in \"\n-                     \"[DD] [HH:[MM:]]ss[.uuuuuu] format.\")\n+                     \"[DD] [[HH:]MM:]ss[.uuuuuu] format.\")\n     }\n     description = _(\"Duration\")\n \n+    def __init__(self, *args, **kwargs):\n+        kwargs.setdefault('help_text', _('Enter a duration in the format [DD] [[HH:]MM:]ss[.uuuuuu].'))\n+        super().__init__(*args, **kwargs)\n+\n     def get_internal_type(self):\n         return \"DurationField\"\n \ndiff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex b73994f8..f1c82ab8 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -75,7 +75,7 @@ class TestValidation(SimpleTestCase):\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11099",
    "model_patch": "diff --git a/django/contrib/auth/validators.py b/django/contrib/auth/validators.py\nindex b4878cfd..1304f20a 100644\n--- a/django/contrib/auth/validators.py\n+++ b/django/contrib/auth/validators.py\n@@ -7,7 +7,7 @@ from django.utils.translation import gettext_lazy as _\n \n @deconstructible\n class ASCIIUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only English letters, '\n         'numbers, and @/./+/-/_ characters.'\n@@ -17,7 +17,7 @@ class ASCIIUsernameValidator(validators.RegexValidator):\n \n @deconstructible\n class UnicodeUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only letters, '\n         'numbers, and @/./+/-/_ characters.'\ndiff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 1c2c6b4a..d3211661 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -259,3 +259,59 @@ class UsernameValidatorsTests(SimpleTestCase):\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n+\n+    def test_ascii_validator_rejects_trailing_newline(self):\n+        \"\"\"\n+        ASCIIUsernameValidator should reject usernames that end with a newline.\n+        Tests the fix for the security issue where $ in regex matches trailing newlines.\n+        \"\"\"\n+        v = validators.ASCIIUsernameValidator()\n+        # These should all be rejected\n+        invalid_usernames = [\n+            'testuser\\n',\n+            'testuser\\r\\n',\n+            'testuser\\r',\n+            'user\\nname',  # newline in middle should also be rejected\n+        ]\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n+\n+    def test_unicode_validator_rejects_trailing_newline(self):\n+        \"\"\"\n+        UnicodeUsernameValidator should reject usernames that end with a newline.\n+        Tests the fix for the security issue where $ in regex matches trailing newlines.\n+        \"\"\"\n+        v = validators.UnicodeUsernameValidator()\n+        # These should all be rejected\n+        invalid_usernames = [\n+            'testuser\\n',\n+            'testuser\\r\\n', \n+            'testuser\\r',\n+            'user\\nname',  # newline in middle should also be rejected\n+            '\u7528\u6237\\n',  # Unicode username with trailing newline\n+        ]\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n+\n+    def test_valid_usernames_without_newlines(self):\n+        \"\"\"\n+        Valid usernames (without newlines) should still be accepted.\n+        \"\"\"\n+        ascii_validator = validators.ASCIIUsernameValidator()\n+        unicode_validator = validators.UnicodeUsernameValidator()\n+        \n+        # Test ASCII usernames\n+        valid_ascii_usernames = ['testuser', 'user.name', 'user@domain', 'user+test', 'user-test', 'user_test']\n+        for valid in valid_ascii_usernames:\n+            with self.subTest(ascii_valid=valid):\n+                ascii_validator(valid)\n+        \n+        # Test Unicode usernames  \n+        valid_unicode_usernames = ['testuser', '\u7528\u6237', 'Ren\u00e9', 'user.name', 'user@domain', 'user+test', 'user-test', 'user_test']\n+        for valid in valid_unicode_usernames:\n+            with self.subTest(unicode_valid=valid):\n+                unicode_validator(valid)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11133",
    "model_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193..a5072852 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -226,10 +226,10 @@ class HttpResponseBase:\n         # an instance of a subclass, this function returns `bytes(value)`.\n         # This doesn't make a copy when `value` already contains bytes.\n \n-        # Handle string types -- we can't rely on force_bytes here because:\n+        # Handle bytes-like objects -- we can't rely on force_bytes here because:\n         # - Python attempts str conversion first\n         # - when self._charset != 'utf-8' it re-encodes the content\n-        if isinstance(value, bytes):\n+        if isinstance(value, (bytes, memoryview)):\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n@@ -309,7 +309,7 @@ class HttpResponse(HttpResponseBase):\n     @content.setter\n     def content(self, value):\n         # Consume iterators upon assignment to allow repeated iteration.\n-        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):\n+        if hasattr(value, '__iter__') and not isinstance(value, (bytes, memoryview, str)):\n             content = b''.join(self.make_bytes(chunk) for chunk in value)\n             if hasattr(value, 'close'):\n                 try:",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11179",
    "model_patch": "",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11283",
    "model_patch": "",
    "model_name_or_path": "sage-agent"
  }
]