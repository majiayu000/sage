[
  {
    "instance_id": "astropy__astropy-6938",
    "model_patch": "diff --git a/astropy/io/fits/fitsrec.py b/astropy/io/fits/fitsrec.py\nindex 574b4073b1..cb79142dce 100644\n--- a/astropy/io/fits/fitsrec.py\n+++ b/astropy/io/fits/fitsrec.py\n@@ -1261,7 +1261,7 @@ class FITS_rec(np.recarray):\n \n         # Replace exponent separator in floating point numbers\n         if 'D' in format:\n-            output_field.replace(encode_ascii('E'), encode_ascii('D'))\n+            output_field = output_field.replace(encode_ascii('E'), encode_ascii('D'))\n \n \n def _get_recarray_field(array, key):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "astropy__astropy-7746",
    "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..3d4c6a1a67 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Check for empty arrays and return early\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return tuple(np.empty_like(axes[0]) for _ in range(2))\n+                else:\n+                    return tuple(np.empty_like(axes[0]) for _ in range(self.naxis))\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n@@ -1235,6 +1242,11 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"When providing two arguments, the array must be \"\n                     \"of shape (N, {0})\".format(self.naxis))\n+\n+            # Check for empty arrays and return early\n+            if xy.size == 0:\n+                return xy.copy()\n+\n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n             result = func(xy, origin)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-10924",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..1fa89d05c3 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1685,6 +1685,12 @@ class FilePathField(Field):\n             ]\n         return []\n \n+    def get_path(self):\n+        \"\"\"\n+        Return the path value, evaluating the path if it's a callable.\n+        \"\"\"\n+        return self.path() if callable(self.path) else self.path\n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n         if self.path != '':\n@@ -1709,7 +1715,7 @@ class FilePathField(Field):\n \n     def formfield(self, **kwargs):\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': self.get_path(),\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..6b60723f96 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1078,7 +1078,10 @@ class MultiValueField(Field):\n class FilePathField(ChoiceField):\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        # Allow path to be a callable\n+        self.path_raw = path\n+        self.path = path() if callable(path) else path\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11001",
    "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7649c39262..0ebca17437 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -353,6 +353,8 @@ class SQLCompiler:\n             # not taken into account so we strip it. When this entire method\n             # is refactored into expressions, then we can check each part as we\n             # generate it.\n+            # Normalize whitespace to handle multiline strings.\n+            sql = ' '.join(sql.split())\n             without_ordering = self.ordering_parts.search(sql).group(1)\n             params_hash = make_hashable(params)\n             if (without_ordering, params_hash) in seen:\n@@ -366,7 +368,9 @@ class SQLCompiler:\n         if self.query.distinct and not self.query.distinct_fields:\n             select_sql = [t[1] for t in select]\n             for expr, (sql, params, is_ref) in order_by:\n-                without_ordering = self.ordering_parts.search(sql).group(1)\n+                # Normalize whitespace to handle multiline strings.\n+                sql_normalized = ' '.join(sql.split())\n+                without_ordering = self.ordering_parts.search(sql_normalized).group(1)\n                 if not is_ref and (without_ordering, params) not in select_sql:\n                     extra_select.append((expr, (without_ordering, params), None))\n         return extra_select",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11019",
    "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..0c39d37485 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -59,22 +59,29 @@ class Media:\n \n     @property\n     def _css(self):\n-        css = self._css_lists[0]\n-        # filter(None, ...) avoids calling merge with empty dicts.\n-        for obj in filter(None, self._css_lists[1:]):\n+        # Collect all non-empty CSS dicts for multi-way merge.\n+        all_dicts = list(filter(None, self._css_lists))\n+        if len(all_dicts) == 1:\n+            return all_dicts[0]\n+        # For CSS, we need to merge by medium.\n+        css = all_dicts[0]\n+        for obj in all_dicts[1:]:\n             css = {\n-                medium: self.merge(css.get(medium, []), obj.get(medium, []))\n+                medium: self.merge_multiple_lists([\n+                    css.get(medium, []),\n+                    obj.get(medium, [])\n+                ])\n                 for medium in css.keys() | obj.keys()\n             }\n         return css\n \n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all non-empty JS lists for multi-way merge.\n+        all_lists = list(filter(None, self._js_lists))\n+        if len(all_lists) == 1:\n+            return all_lists[0]\n+        return self.merge_multiple_lists(all_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -149,6 +156,78 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+    @staticmethod\n+    def merge_multiple_lists(lists):\n+        \"\"\"\n+        Merge multiple lists while trying to keep the relative order of the elements.\n+        Uses topological sort to handle ordering constraints from all lists.\n+\n+        For static assets it can be important to have them included in the DOM\n+        in a certain order. In JavaScript you may not be able to reference a\n+        global or in CSS you might want to override a style.\n+        \"\"\"\n+        if not lists:\n+            return []\n+\n+        # Collect all unique elements and their positions in each list\n+        all_elements = set()\n+        for lst in lists:\n+            all_elements.update(lst)\n+\n+        if not all_elements:\n+            return []\n+\n+        # Build a graph of ordering constraints\n+        # For each list, if element A comes before element B, add edge A -> B\n+        # We'll store the constraints as: for each element, what must come before it\n+        must_come_before = {elem: set() for elem in all_elements}\n+        must_come_after = {elem: set() for elem in all_elements}\n+\n+        for lst in lists:\n+            for i, elem in enumerate(lst):\n+                for later_elem in lst[i + 1:]:\n+                    # elem must come before later_elem\n+                    must_come_after[elem].add(later_elem)\n+                    must_come_before[later_elem].add(elem)\n+\n+        # Detect conflicts (cycles in the constraint graph)\n+        # If we have both A -> B and B -> A, that's a conflict\n+        for elem in all_elements:\n+            for after_elem in must_come_after[elem]:\n+                if elem in must_come_after[after_elem]:\n+                    # We have a cycle: elem -> after_elem and after_elem -> elem\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order:\\n'\n+                        '%s\\n%s' % (elem, after_elem),\n+                        MediaOrderConflictWarning,\n+                    )\n+                    # Break the cycle by removing the conflicting constraint\n+                    must_come_after[elem].discard(after_elem)\n+                    must_come_before[after_elem].discard(elem)\n+\n+        # Perform topological sort using Kahn's algorithm\n+        # Start with elements that have no prerequisites\n+        result = []\n+        # Count in-degrees (number of elements that must come before each element)\n+        in_degree = {elem: len(must_come_before[elem]) for elem in all_elements}\n+\n+        # Start with elements that have no prerequisites\n+        available = [elem for elem in all_elements if in_degree[elem] == 0]\n+\n+        while available:\n+            # Sort to ensure deterministic output (helps with testing)\n+            available.sort()\n+            elem = available.pop(0)\n+            result.append(elem)\n+\n+            # Reduce in-degree for all elements that depended on this one\n+            for after_elem in must_come_after[elem]:\n+                in_degree[after_elem] -= 1\n+                if in_degree[after_elem] == 0:\n+                    available.append(after_elem)\n+\n+        return result\n+\n     def __add__(self, other):\n         combined = Media()\n         combined._css_lists = self._css_lists + other._css_lists",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11039",
    "model_patch": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..93a57b0c33 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -55,8 +55,9 @@ class Command(BaseCommand):\n                 migration_name, app_label))\n         targets = [(app_label, migration.name)]\n \n-        # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+        # Show begin/end around output only for atomic migrations if the\n+        # database supports transactional DDL.\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..663ae6e59a 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,20 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+    def test_sqlmigrate_for_atomic_migration_without_ddl_transaction_support(self):\n+        \"\"\"\n+        Transaction wrappers aren't emitted for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        if connection.ops.start_transaction_sql():\n+            self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n+\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11049",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex f32ce64629..71005490f3 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1587,7 +1587,7 @@ class DurationField(Field):\n     empty_strings_allowed = False\n     default_error_messages = {\n         'invalid': _(\"'%(value)s' value has an invalid format. It must be in \"\n-                     \"[DD] [HH:[MM:]]ss[.uuuuuu] format.\")\n+                     \"[DD] [[HH:]MM:]ss[.uuuuuu] format.\")\n     }\n     description = _(\"Duration\")\n \ndiff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex b73994f86a..f1c82ab8bd 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -75,7 +75,7 @@ class TestValidation(SimpleTestCase):\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11283",
    "model_patch": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..4cbbac819f 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -27,7 +27,7 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        ).exclude(content_type=new_content_type).update(content_type=new_content_type)\n \n \n def revert_proxy_model_permissions(apps, schema_editor):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11422",
    "model_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..cb7cd1c725 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -114,7 +114,15 @@ def iter_modules_and_files(modules, extra_files):\n         # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n         # are added to sys.modules, however they are types not modules and so\n         # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n+        if not isinstance(module, ModuleType):\n+            continue\n+        if module.__name__ == '__main__':\n+            # __main__ (usually manage.py) doesn't always have a __spec__ set.\n+            # Handle this by falling back to using __file__, resolved below.\n+            # See https://docs.python.org/reference/import.html#main-spec\n+            sys_file_paths.append(module.__file__)\n+            continue\n+        if getattr(module, '__spec__', None) is None:\n             continue\n         spec = module.__spec__\n         # Modules could be loaded from places without a concrete location. If",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11583",
    "model_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 25c3b44250..2affc3cec4 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -143,6 +143,10 @@ def iter_modules_and_files(modules, extra_files):\n             # The module could have been removed, don't fail loudly if this\n             # is the case.\n             continue\n+        except ValueError:\n+            # The path could contain a null byte. This can happen with\n+            # certain filesystem structures (e.g., network mountpoints).\n+            continue\n         results.add(resolved_path)\n     return frozenset(results)\n \n@@ -189,6 +193,10 @@ def sys_path_directories():\n             resolved_path = path.resolve(strict=True).absolute()\n         except FileNotFoundError:\n             continue\n+        except ValueError:\n+            # The path could contain a null byte. This can happen with\n+            # certain filesystem structures (e.g., network mountpoints).\n+            continue\n         # If the path is a file (like a zip file), watch the parent directory.\n         if resolved_path.is_file():\n             yield resolved_path.parent",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11620",
    "model_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 2154a46320..5350044b53 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -26,6 +26,7 @@ from django.utils.translation import get_language\n from .converters import get_converter\n from .exceptions import NoReverseMatch, Resolver404\n from .utils import get_callable\n+from django.http import Http404\n \n \n class ResolverMatch:\n@@ -260,6 +261,8 @@ class RoutePattern(CheckURLMixin):\n                     kwargs[key] = converter.to_python(value)\n                 except ValueError:\n                     return None\n+                except Http404:\n+                    raise\n             return path[match.end():], (), kwargs\n         return None\n \ndiff --git a/tests/urlpatterns/tests.py b/tests/urlpatterns/tests.py\nindex 214739f678..524413d72f 100644\n--- a/tests/urlpatterns/tests.py\n+++ b/tests/urlpatterns/tests.py\n@@ -219,6 +219,14 @@ class ConversionExceptionTests(SimpleTestCase):\n         with self.assertRaisesMessage(TypeError, 'This type error propagates.'):\n             resolve('/dynamic/abc/')\n \n+    def test_resolve_http404_propagates(self):\n+        from django.http import Http404\n+        @DynamicConverter.register_to_python\n+        def raises_http404(value):\n+            raise Http404('Not found')\n+        with self.assertRaises(Http404):\n+            resolve('/dynamic/abc/')\n+\n     def test_reverse_value_error_propagates(self):\n         @DynamicConverter.register_to_url\n         def raises_value_error(value):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11630",
    "model_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..00d53a7d63 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -5,6 +5,7 @@ from itertools import chain\n \n from django.apps import apps\n from django.core.checks import Error, Tags, register\n+from django.db import connections\n \n \n @register(Tags.models)\n@@ -37,14 +38,65 @@ def check_all_models(app_configs=None, **kwargs):\n             constraints[model_constraint.name].append(model._meta.label)\n     for db_table, model_labels in db_table_models.items():\n         if len(model_labels) != 1:\n-            errors.append(\n-                Error(\n-                    \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n-                    obj=db_table,\n-                    id='models.E028',\n+            # Check if models with the same db_table can coexist in different databases.\n+            # Build a mapping of model labels to actual model objects\n+            model_map = {}\n+            for model in models:\n+                if model._meta.managed and not model._meta.proxy and model._meta.db_table == db_table:\n+                    model_map[model._meta.label] = model\n+            \n+            # Check each pair of models with the same table name\n+            conflicts = []\n+            model_labels_list = list(model_labels)\n+            \n+            for i in range(len(model_labels_list)):\n+                for j in range(i + 1, len(model_labels_list)):\n+                    model1_label = model_labels_list[i]\n+                    model2_label = model_labels_list[j]\n+                    model1 = model_map[model1_label]\n+                    model2 = model_map[model2_label]\n+                    \n+                    # Check if these two models can coexist in different databases\n+                    # If there exists any database where both can migrate, it's a conflict\n+                    has_conflict = False\n+                    for db in connections:\n+                        try:\n+                            router = connections[db].router\n+                            # Check if both models can migrate to this database\n+                            model1_allowed = router.allow_migrate(\n+                                db, model1._meta.app_label,\n+                                model_name=model1._meta.model_name,\n+                                model=model1\n+                            )\n+                            model2_allowed = router.allow_migrate(\n+                                db, model2._meta.app_label,\n+                                model_name=model2._meta.model_name,\n+                                model=model2\n+                            )\n+                            \n+                            # If both can migrate to the same database, it's a conflict\n+                            if model1_allowed and model2_allowed:\n+                                has_conflict = True\n+                                break\n+                        except (AttributeError, TypeError):\n+                            # If router checking fails, assume conflict for safety\n+                            has_conflict = True\n+                            break\n+                    \n+                    if has_conflict:\n+                        conflicts.extend([model1_label, model2_label])\n+            \n+            # Only raise error if there are actual conflicts\n+            if conflicts:\n+                unique_conflicts = sorted(set(conflicts))\n+                errors.append(\n+                    Error(\n+                        \"db_table '%s' is used by multiple models: %s.\"\n+                        % (db_table, ', '.join(unique_conflicts)),\n+                        obj=db_table,\n+                        id='models.E028',\n+                    )\n                 )\n-            )\n     for index_name, model_labels in indexes.items():\n         if len(model_labels) > 1:\n             model_labels = set(model_labels)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11742",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..fde31b40bc 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -976,7 +976,32 @@ class CharField(Field):\n                 )\n             ]\n         else:\n-            return []\n+            errors = []\n+            if self.choices:\n+                # Check that max_length is large enough for the longest choice\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                    except (TypeError, ValueError):\n+                        # No groups, choices in the form [value, display]\n+                        choice_values = [choices_group[0]]\n+                    else:\n+                        choice_values = [value for value, _ in group_choices]\n+\n+                    for choice_value in choice_values:\n+                        if isinstance(choice_value, str) and len(choice_value) > self.max_length:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'max_length' is too small to fit the longest value \"\n+                                    \"in 'choices' (value %r has %d characters, max_length is %d).\"\n+                                    % (choice_value, len(choice_value), self.max_length),\n+                                    obj=self,\n+                                    id='fields.E009',\n+                                )\n+                            )\n+                            # Only report one error per field\n+                            break\n+            return errors\n \n     def cast_db_type(self, connection):\n         if self.max_length is None:\ndiff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex 5bb1847a70..fe359cdcef 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -352,6 +352,52 @@ class CharFieldTests(SimpleTestCase):\n             )\n         ])\n \n+    def test_max_length_fits_choices(self):\n+        \"\"\"Test that max_length is large enough for the longest choice value.\"\"\"\n+        class Model(models.Model):\n+            field = models.CharField(max_length=5, choices=[('too_long', 'Too Long')])\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value \"\n+                \"in 'choices' (value 'too_long' has 8 characters, max_length is 5).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_fits_grouped_choices(self):\n+        \"\"\"Test that max_length is large enough for grouped choices.\"\"\"\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=5,\n+                choices=[\n+                    ('Group', [\n+                        ('ok', 'OK'),\n+                        ('way_too_long', 'Way Too Long'),\n+                    ])\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value \"\n+                \"in 'choices' (value 'way_too_long' has 11 characters, max_length is 5).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_adequate_for_choices(self):\n+        \"\"\"Test that adequate max_length passes validation.\"\"\"\n+        class Model(models.Model):\n+            field = models.CharField(max_length=10, choices=[('short', 'Short Label')])\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n \n @isolate_apps('invalid_models_tests')\n class DateFieldTests(SimpleTestCase):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11797",
    "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..20433fe30a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -453,7 +453,9 @@ class Query(BaseExpression):\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n                 if inner_query.default_cols and has_existing_aggregate_annotations:\n-                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n+                    # Don't override an existing GROUP BY clause.\n+                    if inner_query.group_by is None:\n+                        inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11815",
    "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379..23e70672ff 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,9 +120,7 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n-        imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n+        return \"%s.%s[%r]\" % (module, enum_class.__name__, self.value.name), {'import %s' % module}\n \n \n class FloatSerializer(BaseSimpleSerializer):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11848",
    "model_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4347..a9ffd319d1 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -176,10 +176,14 @@ def parse_http_date(date):\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n-            if year < 70:\n-                year += 2000\n+            current_year = datetime.datetime.now().year\n+            current_two_digit_year = current_year % 100\n+            current_century = current_year - current_two_digit_year\n+            if year - current_two_digit_year > 50:\n+                # Year appears to be more than 50 years in the future\n+                year += current_century - 100\n             else:\n-                year += 1900\n+                year += current_century\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11905",
    "model_patch": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9344979c56..424c2a98b4 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -462,6 +462,14 @@ class IsNull(BuiltinLookup):\n     lookup_name = 'isnull'\n     prepare_rhs = False\n \n+    def __init__(self, lhs, rhs):\n+        if not hasattr(rhs, 'resolve_expression') and rhs is not None and not isinstance(rhs, bool):\n+            raise ValueError(\n+                \"The __isnull lookup only accepts boolean values (True or False). \"\n+                \"Got %r instead.\" % rhs\n+            )\n+        super().__init__(lhs, rhs)\n+\n     def as_sql(self, compiler, connection):\n         sql, params = compiler.compile(self.lhs)\n         if self.rhs:",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11910",
    "model_patch": "diff --git a/django/db/migrations/operations/fields.py b/django/db/migrations/operations/fields.py\nindex 402dae2829..48f277a593 100644\n--- a/django/db/migrations/operations/fields.py\n+++ b/django/db/migrations/operations/fields.py\n@@ -344,9 +344,22 @@ class RenameField(FieldOperation):\n                         remote_field.model, model_app_label, model_name\n                     )\n                     if remote_model_tuple == model_tuple:\n-                        if getattr(remote_field, 'field_name', None) == self.old_name:\n-                            remote_field.field_name = self.new_name\n+                        field_name = getattr(remote_field, 'field_name', None)\n                         to_fields = getattr(field, 'to_fields', None)\n+                        # Update remote_field.field_name if:\n+                        # 1. It explicitly references the old field name, or\n+                        # 2. It's None (defaults to PK) and to_fields contains None (PK reference)\n+                        #    and the old field is the primary key.\n+                        if field_name == self.old_name:\n+                            remote_field.field_name = self.new_name\n+                        elif field_name is None and to_fields and None in to_fields:\n+                            # Check if the renamed field is the primary key\n+                            renamed_field_is_pk = any(\n+                                f_name == self.old_name and getattr(f, 'primary_key', False)\n+                                for f_name, f in state.models[model_tuple].fields\n+                            )\n+                            if renamed_field_is_pk:\n+                                remote_field.field_name = self.new_name\n                         if to_fields:\n                             field.to_fields = tuple([\n                                 self.new_name if to_field_name == self.old_name else to_field_name",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11964",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..c0cfbf879c 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -792,6 +792,9 @@ class Field(RegisterLookupMixin):\n         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n         if isinstance(value, Promise):\n             value = value._proxy____cast()\n+        # Explicitly handle enum types, e.g. Choice.\n+        if hasattr(value, 'value'):\n+            value = value.value\n         return value\n \n     def get_db_prep_value(self, value, connection, prepared=False):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11999",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex ee45bb941e..64b4a8c35e 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,10 @@ class Field(RegisterLookupMixin):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            display_method = 'get_%s_display' % self.name\n+            # Only set the display method if it's not already defined.\n+            if not getattr(cls, display_method, None):\n+                setattr(cls, display_method, partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\ndiff --git a/tests/model_fields/models.py b/tests/model_fields/models.py\nindex 98b32d0c1e..087840e4dd 100644\n--- a/tests/model_fields/models.py\n+++ b/tests/model_fields/models.py\n@@ -68,6 +68,20 @@ class WhizIterEmpty(models.Model):\n     c = models.CharField(choices=iter(()), blank=True, max_length=1)\n \n \n+class WhizWithCustomDisplay(models.Model):\n+    \"\"\"\n+    A model that overrides the auto-generated get_c_display method.\n+    \"\"\"\n+    CHOICES = (\n+        (1, 'First'),\n+        (2, 'Second'),\n+    )\n+    c = models.IntegerField(choices=CHOICES, null=True)\n+\n+    def get_c_display(self):\n+        return \"Custom Display\"\n+\n+\n class Choiceful(models.Model):\n     no_choices = models.IntegerField(null=True)\n     empty_choices = models.IntegerField(choices=(), null=True)\ndiff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 0d6e930b06..07d61d79b8 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -8,7 +8,7 @@ from django.utils.functional import lazy\n \n from .models import (\n     Bar, Choiceful, Foo, RenamedField, VerboseNameField, Whiz, WhizDelayed,\n-    WhizIter, WhizIterEmpty,\n+    WhizIter, WhizIterEmpty, WhizWithCustomDisplay,\n )\n \n \n@@ -186,6 +186,14 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertIsNone(WhizIterEmpty(c=None).c)         # Blank value\n         self.assertEqual(WhizIterEmpty(c='').c, '')        # Empty value\n \n+    def test_can_override_get_FIELD_display(self):\n+        \"\"\"\n+        get_FIELD_display() can be overridden.\n+        \"\"\"\n+        obj = WhizWithCustomDisplay(c=1)\n+        # The overridden method should return our custom value, not 'First'\n+        self.assertEqual(obj.get_c_display(), 'Custom Display')\n+\n \n class GetChoicesTests(SimpleTestCase):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12113",
    "model_patch": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..d31dea29ec 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -197,6 +197,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n                 RuntimeWarning\n             )\n         kwargs.update({'check_same_thread': False, 'uri': True})\n+        # Set a timeout for SQLite to wait before raising \"database is locked\".\n+        # The default timeout in sqlite3 is 5 seconds, but for better concurrency\n+        # (especially with --keepdb and multiple databases), increase to 30 seconds.\n+        kwargs.setdefault('timeout', 30)\n         return kwargs\n \n     @async_unsafe",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12125",
    "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 7d226955d5..ead81c398a 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -269,7 +269,7 @@ class TypeSerializer(BaseSerializer):\n             if module == builtins.__name__:\n                 return self.value.__name__, set()\n             else:\n-                return \"%s.%s\" % (module, self.value.__name__), {\"import %s\" % module}\n+                return \"%s.%s\" % (module, self.value.__qualname__), {\"import %s\" % module}\n \n \n class UUIDSerializer(BaseSerializer):\ndiff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex ca924f35ec..ad8c79f702 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -744,6 +744,20 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(ValueError, 'Cannot serialize: (1+2j)'):\n             self.assertSerializedEqual(complex(1, 2))\n \n+    def test_serialize_inner_class(self):\n+        \"\"\"\n+        Test that inner classes are correctly serialized with their full path.\n+        \"\"\"\n+        class Outer:\n+            class Inner:\n+                pass\n+\n+        # Inner classes should be serialized with their outer class path\n+        self.assertSerializedResultEqual(\n+            Outer.Inner,\n+            (\"migrations.test_writer.Outer.Inner\", {\"import migrations.test_writer\"})\n+        )\n+\n     def test_register_non_serializer(self):\n         with self.assertRaisesMessage(ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"):\n             MigrationWriter.register_serializer(complex, TestModel1)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12184",
    "model_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 2d4610aac4..817ad4ffaa 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -159,7 +159,7 @@ class RegexPattern(CheckURLMixin):\n             # non-named groups. Otherwise, pass all non-named arguments as\n             # positional arguments.\n             kwargs = {k: v for k, v in match.groupdict().items() if v is not None}\n-            args = () if kwargs else match.groups()\n+            args = () if match.groupdict() else match.groups()\n             return path[match.end():], args, kwargs\n         return None",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12284",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..cccb56d08c 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -764,12 +764,11 @@ class Field(RegisterLookupMixin):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            if not hasattr(cls, 'get_%s_display' % self.name):\n-                setattr(\n-                    cls,\n-                    'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n-                )\n+            setattr(\n+                cls,\n+                'get_%s_display' % self.name,\n+                partialmethod(cls._get_FIELD_display, field=self),\n+            )\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12286",
    "model_patch": "diff --git a/django/core/checks/translation.py b/django/core/checks/translation.py\nindex 138ed07ff8..3eaddb0101 100644\n--- a/django/core/checks/translation.py\n+++ b/django/core/checks/translation.py\n@@ -1,5 +1,5 @@\n from django.conf import settings\n-from django.utils.translation.trans_real import language_code_re\n+from django.utils.translation.trans_real import check_for_language, language_code_re\n \n from . import Error, Tags, register\n \n@@ -56,6 +56,12 @@ def check_setting_languages_bidi(app_configs, **kwargs):\n def check_language_settings_consistent(app_configs, **kwargs):\n     \"\"\"Error if language settings are not consistent with each other.\"\"\"\n     available_tags = {i for i, _ in settings.LANGUAGES} | {'en-us'}\n-    if settings.LANGUAGE_CODE not in available_tags:\n-        return [E004]\n-    return []\n+    if settings.LANGUAGE_CODE in available_tags:\n+        return []\n+    # If a base language is available but the sublanguage is not, the base\n+    # language is used. For example, if 'de' is available but 'de-at' is not,\n+    # 'de' is used for 'de-at'.\n+    base_language = settings.LANGUAGE_CODE.split('-')[0]\n+    if base_language in available_tags and check_for_language(base_language):\n+        return []\n+    return [E004]",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12308",
    "model_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex e4ddc8f017..71745daaee 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -390,7 +390,9 @@ def display_for_field(value, field, empty_value_display):\n         return empty_value_display\n     elif isinstance(field, models.DateTimeField):\n         return formats.localize(timezone.template_localtime(value))\n-    elif isinstance(field, (models.DateField, models.TimeField)):\n+    elif isinstance(field, models.DateField):\n+        return formats.localize(value)\n+    elif isinstance(field, models.TimeField):\n         return formats.localize(value)\n     elif isinstance(field, models.DecimalField):\n         return formats.number_format(value, field.decimal_places)\n@@ -398,6 +400,8 @@ def display_for_field(value, field, empty_value_display):\n         return formats.number_format(value)\n     elif isinstance(field, models.FileField) and value:\n         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    elif isinstance(field, models.JSONField):\n+        return field.formfield().prepare_value(value)\n     else:\n         return display_for_value(value, empty_value_display)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12453",
    "model_patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex c50fc90171..5cf1f5b3c2 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -5,7 +5,7 @@ from io import StringIO\n from django.apps import apps\n from django.conf import settings\n from django.core import serializers\n-from django.db import router\n+from django.db import router, transaction\n \n # The prefix to put on the default database name when creating\n # the test database.\n@@ -126,8 +126,9 @@ class BaseDatabaseCreation:\n         the serialize_db_to_string() method.\n         \"\"\"\n         data = StringIO(data)\n-        for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n-            obj.save()\n+        with transaction.atomic(using=self.connection.alias):\n+            for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n+                obj.save()\n \n     def _get_database_display_str(self, verbosity, database_name):\n         \"\"\"",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12470",
    "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..a8e3ad8e97 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,7 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       'ASC', already_seen))\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12497",
    "model_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 8ddbb5ba68..536b3dd601 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1309,7 +1309,7 @@ class ManyToManyField(RelatedField):\n                              \"through_fields keyword argument.\") % (self, from_model_name),\n                             hint=(\n                                 'If you want to create a recursive relationship, '\n-                                'use ForeignKey(\"%s\", symmetrical=False, through=\"%s\").'\n+                                'use ManyToManyField(\"%s\", through=\"%s\").'\n                             ) % (\n                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n                                 relationship_model_name,\n@@ -1329,7 +1329,7 @@ class ManyToManyField(RelatedField):\n                             \"through_fields keyword argument.\" % (self, to_model_name),\n                             hint=(\n                                 'If you want to create a recursive relationship, '\n-                                'use ForeignKey(\"%s\", symmetrical=False, through=\"%s\").'\n+                                'use ManyToManyField(\"%s\", through=\"%s\").'\n                             ) % (\n                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n                                 relationship_model_name,\ndiff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 24f27168c2..6ff5a2fa41 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -152,7 +152,7 @@ class RelativeFieldTests(SimpleTestCase):\n                 \"keyword argument.\",\n                 hint=(\n                     'If you want to create a recursive relationship, use '\n-                    'ForeignKey(\"self\", symmetrical=False, through=\"AmbiguousRelationship\").'\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n                 ),\n                 obj=field,\n                 id='fields.E335',",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12700",
    "model_patch": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..41ebca7c89 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -84,12 +84,15 @@ class SafeExceptionReporterFilter:\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        If the value is a list or tuple, recursively cleanse each element.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                cleansed = type(value)(self.cleanse_setting('', v) for v in value)\n             else:\n                 cleansed = value\n         except TypeError:",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12708",
    "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..1f521cfc5c 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,7 +393,7 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\ndiff --git a/tests/schema/models.py b/tests/schema/models.py\nindex 6d4465807a..088be2b4eb 100644\n--- a/tests/schema/models.py\n+++ b/tests/schema/models.py\n@@ -80,6 +80,20 @@ class AuthorWithUniqueNameAndBirthday(models.Model):\n         unique_together = [['name', 'birthday']]\n \n \n+class AuthorWithUniqueAndIndexedNameAndBirthday(models.Model):\n+    \"\"\"\n+    Model with both unique_together and index_together on the same fields.\n+    Used for testing that deleting index_together doesn't fail when unique_together exists.\n+    \"\"\"\n+    name = models.CharField(max_length=255)\n+    birthday = models.DateField()\n+\n+    class Meta:\n+        apps = new_apps\n+        unique_together = [['name', 'birthday']]\n+        index_together = [['name', 'birthday']]\n+\n+\n class Book(models.Model):\n     author = models.ForeignKey(Author, models.CASCADE)\n     title = models.CharField(max_length=100, db_index=True)\ndiff --git a/tests/schema/tests.py b/tests/schema/tests.py\nindex 9aa1e239ac..5659c35c71 100644\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -29,7 +29,8 @@ from .models import (\n     Author, AuthorCharFieldWithIndex, AuthorTextFieldWithIndex,\n     AuthorWithDefaultHeight, AuthorWithEvenLongerName, AuthorWithIndexedName,\n     AuthorWithIndexedNameAndBirthday, AuthorWithUniqueName,\n-    AuthorWithUniqueNameAndBirthday, Book, BookForeignObj, BookWeak,\n+    AuthorWithUniqueNameAndBirthday, AuthorWithUniqueAndIndexedNameAndBirthday,\n+    Book, BookForeignObj, BookWeak,\n     BookWithLongName, BookWithO2O, BookWithoutAuthor, BookWithSlug, IntegerPK,\n     Node, Note, NoteRename, Tag, TagIndexed, TagM2MTest, TagUniqueRename,\n     Thing, UniqueTest, new_apps,\n@@ -52,6 +53,7 @@ class SchemaTests(TransactionTestCase):\n         AuthorWithDefaultHeight, AuthorWithEvenLongerName, Book, BookWeak,\n         BookWithLongName, BookWithO2O, BookWithSlug, IntegerPK, Node, Note,\n         Tag, TagIndexed, TagM2MTest, TagUniqueRename, Thing, UniqueTest,\n+        AuthorWithUniqueAndIndexedNameAndBirthday,\n     ]\n \n     # Utility functions\n@@ -2245,6 +2247,51 @@ class SchemaTests(TransactionTestCase):\n             AuthorWithIndexedNameAndBirthday._meta.indexes = []\n             editor.remove_index(AuthorWithIndexedNameAndBirthday, index)\n \n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_delete_index_together_with_unique_together(self):\n+        \"\"\"\n+        Tests that deleting index_together when unique_together exists on the\n+        same fields doesn't fail. This is a regression test for #12708.\n+        \"\"\"\n+        # Create the table with both unique_together and index_together\n+        with connection.schema_editor() as editor:\n+            editor.create_model(AuthorWithUniqueAndIndexedNameAndBirthday)\n+\n+        # Ensure both constraints exist\n+        constraints = self.get_constraints(AuthorWithUniqueAndIndexedNameAndBirthday._meta.db_table)\n+        unique_constraints = [\n+            name for name, details in constraints.items()\n+            if details['columns'] == ['name', 'birthday'] and details['unique']\n+        ]\n+        index_constraints = [\n+            name for name, details in constraints.items()\n+            if details['columns'] == ['name', 'birthday'] and details['index'] and not details['unique']\n+        ]\n+        self.assertEqual(len(unique_constraints), 1, \"Should have 1 unique constraint\")\n+        self.assertEqual(len(index_constraints), 1, \"Should have 1 index constraint\")\n+\n+        # Delete the index_together (this should not fail)\n+        index_together = AuthorWithUniqueAndIndexedNameAndBirthday._meta.index_together\n+        with connection.schema_editor() as editor:\n+            editor.alter_index_together(\n+                AuthorWithUniqueAndIndexedNameAndBirthday,\n+                index_together,\n+                []\n+            )\n+\n+        # Ensure the unique constraint still exists but the index is gone\n+        constraints = self.get_constraints(AuthorWithUniqueAndIndexedNameAndBirthday._meta.db_table)\n+        unique_constraints = [\n+            name for name, details in constraints.items()\n+            if details['columns'] == ['name', 'birthday'] and details['unique']\n+        ]\n+        index_constraints = [\n+            name for name, details in constraints.items()\n+            if details['columns'] == ['name', 'birthday'] and details['index'] and not details['unique']\n+        ]\n+        self.assertEqual(len(unique_constraints), 1, \"Unique constraint should still exist\")\n+        self.assertEqual(len(index_constraints), 0, \"Index constraint should be removed\")\n+\n     @isolate_apps('schema')\n     def test_db_table(self):\n         \"\"\"",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12747",
    "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..998b2625a0 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -442,4 +442,6 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        # Remove keys with zero counts to ensure consistency\n+        deleted_counter = Counter({k: v for k, v in deleted_counter.items() if v > 0})\n         return sum(deleted_counter.values()), dict(deleted_counter)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12856",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..aa8c787f35 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1866,6 +1866,10 @@ class Model(metaclass=ModelBase):\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        # Check that fields mentioned in UniqueConstraints exist.\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12908",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..46ae62a816 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1140,6 +1140,11 @@ class QuerySet:\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot create distinct fields once a slice has been taken.\"\n+        if self.query.combinator and field_names:\n+            raise NotSupportedError(\n+                'Calling QuerySet.distinct() with fields after %s() is not supported.'\n+                % self.query.combinator\n+            )\n         obj = self._chain()\n         obj.query.add_distinct_fields(*field_names)\n         return obj",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12915",
    "model_patch": "diff --git a/django/contrib/staticfiles/handlers.py b/django/contrib/staticfiles/handlers.py\nindex 711d8864ad..9db4d33b33 100644\n--- a/django/contrib/staticfiles/handlers.py\n+++ b/django/contrib/staticfiles/handlers.py\n@@ -52,6 +52,12 @@ class StaticFilesHandlerMixin:\n         except Http404 as e:\n             return response_for_exception(request, e)\n \n+    async def get_response_async(self, request):\n+        try:\n+            return self.serve(request)\n+        except Http404 as e:\n+            return response_for_exception(request, e)\n+\n \n class StaticFilesHandler(StaticFilesHandlerMixin, WSGIHandler):\n     \"\"\"",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-12983",
    "model_patch": "diff --git a/django/utils/text.py b/django/utils/text.py\nindex fb5f6298c4..3ba4bbb3f4 100644\n--- a/django/utils/text.py\n+++ b/django/utils/text.py\n@@ -403,7 +403,7 @@ def slugify(value, allow_unicode=False):\n     else:\n         value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii')\n     value = re.sub(r'[^\\w\\s-]', '', value.lower()).strip()\n-    return re.sub(r'[-\\s]+', '-', value)\n+    return re.sub(r'[-\\s]+', '-', value).strip('-_')\n \n \n def camel_case_to_spaces(value):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13028",
    "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..d7091aa8b4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1124,6 +1124,8 @@ class Query(BaseExpression):\n \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        if hasattr(expression, '_meta'):\n+            return\n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13033",
    "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..a8f5b61fbe 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,7 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != pieces[-1] and name != 'pk':\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13158",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..8f7a81d9e3 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -920,6 +920,13 @@ class QuerySet:\n         \"\"\"Return an empty QuerySet.\"\"\"\n         clone = self._chain()\n         clone.query.set_empty()\n+        # Also set empty on all combined queries if this is a combined queryset\n+        if clone.query.combinator:\n+            clone.query.combined_queries = tuple(\n+                q.clone() for q in clone.query.combined_queries\n+            )\n+            for combined_query in clone.query.combined_queries:\n+                combined_query.set_empty()\n         return clone\n \n     ##################################################################",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13220",
    "model_patch": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..019f059f35 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,75 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return NotImplemented\n+        return self._compare_errors(other)\n+\n+    def _compare_errors(self, other):\n+        \"\"\"Compare two ValidationErrors, handling dict and list structures.\"\"\"\n+        self_has_dict = hasattr(self, 'error_dict')\n+        other_has_dict = hasattr(other, 'error_dict')\n+\n+        # Both have error_dict\n+        if self_has_dict and other_has_dict:\n+            return self._compare_error_dict(other)\n+        # Neither has error_dict\n+        elif not self_has_dict and not other_has_dict:\n+            return self._compare_error_list(other)\n+        # One has error_dict, one doesn't\n+        else:\n+            return False\n+\n+    def _compare_error_dict(self, other):\n+        \"\"\"Compare error_dict in an order-independent way.\"\"\"\n+        if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+            return False\n+        for field in self.error_dict:\n+            self_errors = self.error_dict[field]\n+            other_errors = other.error_dict[field]\n+            # Compare as lists of ValidationError objects\n+            if len(self_errors) != len(other_errors):\n+                return False\n+            # Sort both lists by their comparison key for order-independent comparison\n+            self_sorted = sorted(self_errors, key=_error_key)\n+            other_sorted = sorted(other_errors, key=_error_key)\n+            for self_error, other_error in zip(self_sorted, other_sorted):\n+                if not self_error._compare_single_error(other_error):\n+                    return False\n+        return True\n+\n+    def _compare_error_list(self, other):\n+        \"\"\"Compare error_list in an order-independent way.\"\"\"\n+        if len(self.error_list) != len(other.error_list):\n+            return False\n+        # Sort both lists by their comparison key for order-independent comparison\n+        self_sorted = sorted(self.error_list, key=_error_key)\n+        other_sorted = sorted(other.error_list, key=_error_key)\n+        for self_error, other_error in zip(self_sorted, other_sorted):\n+            if not self_error._compare_single_error(other_error):\n+                return False\n+        return True\n+\n+    def _compare_single_error(self, other):\n+        \"\"\"Compare a single ValidationError (message, code, params).\"\"\"\n+        self_message = self.message\n+        other_message = other.message\n+        # Apply params if they exist to get the final message\n+        if self.params:\n+            self_message = self_message % self.params\n+        if other.params:\n+            other_message = other_message % other.params\n+        return str(self_message) == str(other_message)\n+\n+\n+def _error_key(error):\n+    \"\"\"Generate a comparison key for a ValidationError.\"\"\"\n+    message = error.message\n+    if error.params:\n+        message = message % error.params\n+    return (str(message), error.code or '', error.params or ())\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\ndiff --git a/tests/test_exceptions/test_validation_error.py b/tests/test_exceptions/test_validation_error.py\nindex a0bbfaf77e..417f8d8e7d 100644\n--- a/tests/test_exceptions/test_validation_error.py\n+++ b/tests/test_exceptions/test_validation_error.py\n@@ -14,3 +14,62 @@ class TestValidationError(unittest.TestCase):\n         message_dict['field2'] = ['E3', 'E4']\n         exception = ValidationError(message_dict)\n         self.assertEqual(sorted(exception.messages), ['E1', 'E2', 'E3', 'E4'])\n+\n+    def test_eq_simple_validation_errors(self):\n+        # Simple ValidationErrors with same message are equal\n+        e1 = ValidationError('error1')\n+        e2 = ValidationError('error1')\n+        self.assertEqual(e1, e2)\n+\n+    def test_eq_simple_validation_errors_different_messages(self):\n+        # Simple ValidationErrors with different messages are not equal\n+        e1 = ValidationError('error1')\n+        e2 = ValidationError('error2')\n+        self.assertNotEqual(e1, e2)\n+\n+    def test_eq_list_validation_errors_same_order(self):\n+        # List ValidationErrors with same messages in same order are equal\n+        e1 = ValidationError(['error1', 'error2'])\n+        e2 = ValidationError(['error1', 'error2'])\n+        self.assertEqual(e1, e2)\n+\n+    def test_eq_list_validation_errors_different_order(self):\n+        # List ValidationErrors with same messages in different order are equal\n+        e1 = ValidationError(['error2', 'error1'])\n+        e2 = ValidationError(['error1', 'error2'])\n+        self.assertEqual(e1, e2)\n+\n+    def test_eq_dict_validation_errors_same_order(self):\n+        # Dict ValidationErrors with same fields and messages in same order are equal\n+        e1 = ValidationError({'field1': ['error1', 'error2']})\n+        e2 = ValidationError({'field1': ['error1', 'error2']})\n+        self.assertEqual(e1, e2)\n+\n+    def test_eq_dict_validation_errors_different_order(self):\n+        # Dict ValidationErrors with same fields and messages in different order are equal\n+        e1 = ValidationError({'field1': ['error2', 'error1']})\n+        e2 = ValidationError({'field1': ['error1', 'error2']})\n+        self.assertEqual(e1, e2)\n+\n+    def test_eq_dict_validation_errors_different_fields(self):\n+        # Dict ValidationErrors with same messages but different fields are not equal\n+        e1 = ValidationError({'field1': ['error1']})\n+        e2 = ValidationError({'field2': ['error1']})\n+        self.assertNotEqual(e1, e2)\n+\n+    def test_eq_different_types(self):\n+        # ValidationError is not equal to other types\n+        e1 = ValidationError('error')\n+        self.assertNotEqual(e1, 'error')\n+\n+    def test_eq_with_params(self):\n+        # ValidationErrors with same params are equal\n+        e1 = ValidationError('Error %(value)s', params={'value': 1})\n+        e2 = ValidationError('Error %(value)s', params={'value': 1})\n+        self.assertEqual(e1, e2)\n+\n+    def test_eq_with_different_params(self):\n+        # ValidationErrors with different params are not equal\n+        e1 = ValidationError('Error %(value)s', params={'value': 1})\n+        e2 = ValidationError('Error %(value)s', params={'value': 2})\n+        self.assertNotEqual(e1, e2)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13230",
    "model_patch": "diff --git a/django/contrib/syndication/views.py b/django/contrib/syndication/views.py\nindex 68ffb0bfe0..1be9d97b8a 100644\n--- a/django/contrib/syndication/views.py\n+++ b/django/contrib/syndication/views.py\n@@ -74,6 +74,9 @@ class Feed:\n             return [enc]\n         return []\n \n+    def item_comments(self, item):\n+        return None\n+\n     def _get_dynamic_attr(self, attname, obj, default=None):\n         try:\n             attr = getattr(self, attname)\n@@ -214,6 +217,7 @@ class Feed:\n                 author_link=author_link,\n                 categories=self._get_dynamic_attr('item_categories', item),\n                 item_copyright=self._get_dynamic_attr('item_copyright', item),\n+                comments=self._get_dynamic_attr('item_comments', item),\n                 **self.item_extra_kwargs(item)\n             )\n         return feed",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13265",
    "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..a9532d8263 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -1015,12 +1015,27 @@ class MigrationAutodetector:\n     def generate_added_indexes(self):\n         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n             for index in alt_indexes['added_indexes']:\n+                # Determine if the index fields include the _order field\n+                # and if order_with_respect_to is being added.\n+                old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n+                old_model_state = self.from_state.models[app_label, old_model_name]\n+                new_model_state = self.to_state.models[app_label, model_name]\n+                old_order_with_respect_to = old_model_state.options.get(\"order_with_respect_to\")\n+                new_order_with_respect_to = new_model_state.options.get(\"order_with_respect_to\")\n+                order_with_respect_to_added = (\n+                    new_order_with_respect_to and not old_order_with_respect_to\n+                )\n+                dependencies = []\n+                if order_with_respect_to_added and '_order' in index.fields:\n+                    # AddIndex operation must come after AlterOrderWithRespectTo.\n+                    dependencies.append((app_label, model_name, new_order_with_respect_to, True))\n                 self.add_operation(\n                     app_label,\n                     operations.AddIndex(\n                         model_name=model_name,\n                         index=index,\n-                    )\n+                    ),\n+                    dependencies=dependencies,\n                 )\n \n     def generate_removed_indexes(self):\ndiff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 236af43834..4359194c8a 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2137,6 +2137,33 @@ class AutodetectorTests(TestCase):\n         self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"author\", order_with_respect_to=None)\n         self.assertOperationAttributes(changes, 'testapp', 0, 1, model_name=\"author\", name=\"book\")\n \n+    def test_add_alter_order_with_respect_to_with_index(self):\n+        \"\"\"\n+        Setting order_with_respect_to when adding an index on _order field\n+        generates operations in the correct order.\n+        \"\"\"\n+        # Author with order_with_respect_to and an index including _order\n+        author_with_order_and_index = ModelState(\"testapp\", \"Author\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"name\", models.CharField(max_length=200)),\n+            (\"book\", models.ForeignKey(\"otherapp.Book\", models.CASCADE)),\n+        ], options={\n+            \"order_with_respect_to\": \"book\",\n+            \"indexes\": [\n+                models.Index(fields=['book', '_order'], name='book_order_idx'),\n+            ],\n+        })\n+        changes = self.get_changes([self.book, self.author_with_book], [self.book, author_with_order_and_index])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        # AlterOrderWithRespectTo should come before AddIndex\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterOrderWithRespectTo\", \"AddIndex\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"author\", order_with_respect_to=\"book\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, model_name=\"author\", index__name='book_order_idx')\n+        # Verify the dependency exists\n+        add_index_op = changes['testapp'][0].operations[1]\n+        self.assertEqual(add_index_op._auto_deps, [('testapp', 'author', 'book', True)])\n+\n     def test_add_model_order_with_respect_to(self):\n         \"\"\"\n         Setting order_with_respect_to when adding the whole model",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13315",
    "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..f993bb9c98 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -100,7 +100,7 @@ def apply_limit_choices_to_to_formfield(formfield):\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13321",
    "model_patch": "diff --git a/django/contrib/sessions/backends/base.py b/django/contrib/sessions/backends/base.py\nindex 187e14b1b7..4678f756d9 100644\n--- a/django/contrib/sessions/backends/base.py\n+++ b/django/contrib/sessions/backends/base.py\n@@ -1,4 +1,5 @@\n import base64\n+import binascii\n import logging\n import string\n import warnings\n@@ -132,7 +133,10 @@ class SessionBase:\n \n     def _legacy_decode(self, session_data):\n         # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.\n-        encoded_data = base64.b64decode(session_data.encode('ascii'))\n+        try:\n+            encoded_data = base64.b64decode(session_data.encode('ascii'))\n+        except binascii.Error:\n+            return {}\n         try:\n             # could produce ValueError if there is no ':'\n             hash, serialized = encoded_data.split(b':', 1)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13401",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 28374272f4..bdab6b905f 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -516,16 +516,28 @@ class Field(RegisterLookupMixin):\n     def __eq__(self, other):\n         # Needed for @total_ordering\n         if isinstance(other, Field):\n-            return self.creation_counter == other.creation_counter\n+            return (self.creation_counter == other.creation_counter) and (\n+                hasattr(self, 'model') and hasattr(other, 'model') and\n+                self.model == other.model\n+            )\n         return NotImplemented\n \n     def __lt__(self, other):\n         # This is needed because bisect does not take a comparison function.\n         if isinstance(other, Field):\n+            # Order by model first, then by creation_counter to avoid\n+            # re-ordering fields in cases not affected by this equality collision\n+            if hasattr(self, 'model') and hasattr(other, 'model'):\n+                if self.model != other.model:\n+                    return self.model._meta.label < other.model._meta.label\n             return self.creation_counter < other.creation_counter\n         return NotImplemented\n \n     def __hash__(self):\n+        # Include model in hash to ensure fields from different models\n+        # have different hashes even if they have the same creation_counter\n+        if hasattr(self, 'model'):\n+            return hash((self.creation_counter, self.model._meta.label))\n         return hash(self.creation_counter)\n \n     def __deepcopy__(self, memodict):",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13447",
    "model_patch": "diff --git a/django/contrib/admin/sites.py b/django/contrib/admin/sites.py\nindex 837dabfea8..252706d837 100644\n--- a/django/contrib/admin/sites.py\n+++ b/django/contrib/admin/sites.py\n@@ -430,7 +430,7 @@ class AdminSite:\n                     return HttpResponsePermanentRedirect(path)\n         raise Http404\n \n-    def _build_app_dict(self, request, label=None):\n+    def build_app_dict(self, request, label=None):\n         \"\"\"\n         Build the app dictionary. The optional `label` parameter filters models\n         of a specific app.\n@@ -463,6 +463,7 @@ class AdminSite:\n             model_dict = {\n                 'name': capfirst(model._meta.verbose_name_plural),\n                 'object_name': model._meta.object_name,\n+                'model': model,\n                 'perms': perms,\n                 'admin_url': None,\n                 'add_url': None,\n@@ -503,7 +504,7 @@ class AdminSite:\n         Return a sorted list of all the installed apps that have been\n         registered in this site.\n         \"\"\"\n-        app_dict = self._build_app_dict(request)\n+        app_dict = self.build_app_dict(request)\n \n         # Sort the apps alphabetically.\n         app_list = sorted(app_dict.values(), key=lambda x: x['name'].lower())\n@@ -534,7 +535,7 @@ class AdminSite:\n         return TemplateResponse(request, self.index_template or 'admin/index.html', context)\n \n     def app_index(self, request, app_label, extra_context=None):\n-        app_dict = self._build_app_dict(request, app_label)\n+        app_dict = self.build_app_dict(request, app_label)\n         if not app_dict:\n             raise Http404('The requested admin page does not exist.')\n         # Sort the models alphabetically within each app.",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13448",
    "model_patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..093bb59943 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -74,7 +74,7 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13551",
    "model_patch": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..807d923e81 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -85,6 +85,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field is included to invalidate tokens when the email\n+           address is changed.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +96,8 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        email = getattr(user, user.get_email_field_name(), '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + str(email)\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13590",
    "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..ac88bae97b 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1078,8 +1078,8 @@ class Query(BaseExpression):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n             return type(value)(\n-                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n-                for sub_value in value\n+                *(self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n+                for sub_value in value)\n             )\n         return value",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-13658",
    "model_patch": "diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py\nindex 1ba093e51f..4e30a28f33 100644\n--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -344,7 +344,12 @@ class ManagementUtility:\n         # Preprocess options to extract --settings and --pythonpath.\n         # These options could affect the commands that are available, so they\n         # must be processed early.\n-        parser = CommandParser(usage='%(prog)s subcommand [options] [args]', add_help=False, allow_abbrev=False)\n+        parser = CommandParser(\n+            prog=self.prog_name,\n+            usage='%(prog)s subcommand [options] [args]',\n+            add_help=False,\n+            allow_abbrev=False,\n+        )\n         parser.add_argument('--settings')\n         parser.add_argument('--pythonpath')\n         parser.add_argument('args', nargs='*')  # catch-all",
    "model_name_or_path": "sage-agent"
  }
]