[
  {
    "instance_id": "django__django-10914",
    "model_patch": "diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py\nindex acee9887..bdeec806 100644\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -304,7 +304,7 @@ FILE_UPLOAD_TEMP_DIR = None\n \n # The numeric mode to set newly-uploaded files to. The value should be a mode\n # you'd pass directly to os.chmod; see https://docs.python.org/library/os.html#files-and-directories.\n-FILE_UPLOAD_PERMISSIONS = None\n+FILE_UPLOAD_PERMISSIONS = 0o644\n \n # The numeric mode to assign to newly-created directories, when uploading files.\n # The value should be a mode as you'd pass to os.chmod;",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-10924",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748c..0978aa26 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1685,9 +1685,17 @@ class FilePathField(Field):\n             ]\n         return []\n \n+    def _get_path(self):\n+        \"\"\"\n+        Return the resolved path, calling it if it's a callable.\n+        \"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n+        if self.path != '' and not callable(self.path):\n             kwargs['path'] = self.path\n         if self.match is not None:\n             kwargs['match'] = self.match\n@@ -1709,7 +1717,7 @@ class FilePathField(Field):\n \n     def formfield(self, **kwargs):\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': self._get_path(),\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11001",
    "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7649c392..a83f0dc7 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -353,7 +353,9 @@ class SQLCompiler:\n             # not taken into account so we strip it. When this entire method\n             # is refactored into expressions, then we can check each part as we\n             # generate it.\n-            without_ordering = self.ordering_parts.search(sql).group(1)\n+            # Normalize SQL by removing newlines to handle multiline RawSQL expressions\n+            sql_oneline = ' '.join(sql.splitlines())\n+            without_ordering = self.ordering_parts.search(sql_oneline).group(1)\n             params_hash = make_hashable(params)\n             if (without_ordering, params_hash) in seen:\n                 continue\n@@ -366,7 +368,9 @@ class SQLCompiler:\n         if self.query.distinct and not self.query.distinct_fields:\n             select_sql = [t[1] for t in select]\n             for expr, (sql, params, is_ref) in order_by:\n-                without_ordering = self.ordering_parts.search(sql).group(1)\n+                # Normalize SQL by removing newlines to handle multiline RawSQL expressions\n+                sql_oneline = ' '.join(sql.splitlines())\n+                without_ordering = self.ordering_parts.search(sql_oneline).group(1)\n                 if not is_ref and (without_ordering, params) not in select_sql:\n                     extra_select.append((expr, (without_ordering, params), None))\n         return extra_select",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11019",
    "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b2..02b100b6 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -125,29 +125,96 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n-                        MediaOrderConflictWarning,\n-                    )\n-                # path already exists in the list. Update last_insert_index so\n-                # that the following elements are inserted in front of this one.\n-                last_insert_index = index\n-        return combined_list\n+        # Check for actual order conflicts between common elements\n+        conflict_files = Media._find_order_conflict(list_1, list_2)\n+        if conflict_files:\n+            warnings.warn(\n+                'Detected duplicate Media files in an opposite order:\\n'\n+                '%s\\n%s' % conflict_files,\n+                MediaOrderConflictWarning,\n+            )\n+        \n+        # Create a set of all unique items\n+        all_items = list(dict.fromkeys(list_1 + list_2))  # Preserve order of first appearance\n+        \n+        # Build ordering constraints from both lists (only for items that appear together)\n+        constraints = {}\n+        \n+        def add_constraints_from_list(items):\n+            for i in range(len(items) - 1):\n+                item = items[i]\n+                next_item = items[i + 1]\n+                if item not in constraints:\n+                    constraints[item] = set()\n+                constraints[item].add(next_item)\n+        \n+        add_constraints_from_list(list_1)\n+        add_constraints_from_list(list_2)\n+        \n+        # Perform topological sort with constraints as \"soft\" preferences\n+        # Start with all items in their original order\n+        result = list(all_items)\n+        \n+        # Iteratively improve the ordering to respect constraints\n+        changed = True\n+        iterations = 0\n+        max_iterations = len(all_items) * 2  # Prevent infinite loops\n+        \n+        while changed and iterations < max_iterations:\n+            changed = False\n+            iterations += 1\n+            \n+            for i in range(len(result)):\n+                for j in range(i + 1, len(result)):\n+                    earlier = result[i]\n+                    later = result[j]\n+                    \n+                    # If there's a constraint that later should come before earlier, swap them\n+                    if later in constraints.get(earlier, set()):\n+                        result[i], result[j] = result[j], result[i]\n+                        changed = True\n+                        break\n+                \n+                if changed:\n+                    break\n+        \n+        return result\n+\n+    @staticmethod\n+    def _find_order_conflict(list_1, list_2):\n+        \"\"\"\n+        Find two files that appear in both lists but in different relative orders.\n+        Returns a tuple of (file1, file2) if a conflict is found, None otherwise.\n+        \"\"\"\n+        # Find files that appear in both lists\n+        common_files = set(list_1) & set(list_2)\n+        if len(common_files) < 2:\n+            return None\n+        \n+        # Create position maps for faster lookup\n+        pos1 = {file: i for i, file in enumerate(list_1)}\n+        pos2 = {file: i for i, file in enumerate(list_2)}\n+        \n+        # Check each pair of common files for conflicting order\n+        common_list = list(common_files)\n+        for i in range(len(common_list)):\n+            for j in range(i + 1, len(common_list)):\n+                file1, file2 = common_list[i], common_list[j]\n+                \n+                # Get positions in both lists\n+                pos1_file1 = pos1[file1]\n+                pos1_file2 = pos1[file2]\n+                pos2_file1 = pos2[file1]\n+                pos2_file2 = pos2[file2]\n+                \n+                # Check if the order is different\n+                list1_order = pos1_file1 < pos1_file2\n+                list2_order = pos2_file1 < pos2_file2\n+                \n+                if list1_order != list2_order:\n+                    return (file1, file2)\n+        \n+        return None\n \n     def __add__(self, other):\n         combined = Media()",
    "model_name_or_path": "sage-agent"
  },
  {
    "instance_id": "django__django-11039",
    "model_patch": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b66322..5304a5f4 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -55,8 +55,8 @@ class Command(BaseCommand):\n                 migration_name, app_label))\n         targets = [(app_label, migration.name)]\n \n-        # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+        # Show begin/end around output only for atomic migrations that support transactional DDL\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fd..be49793f 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,21 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_database_without_rollback_ddl(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support transactional DDL,\n+        even for atomic migrations.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        if connection.ops.start_transaction_sql():\n+            self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n+\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",",
    "model_name_or_path": "sage-agent"
  }
]